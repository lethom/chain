-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on the Nest at
--   <a>https://nest.pijul.com/lthms/chain.hs</a>
@package chain
@version 0.1.0.0

module Control.Monad.Chain
data ResultT msg (err :: [*]) m a

-- | Escape from the ResultT monad.
--   
--   The type signature of <a>runResultT</a> obliges the library user to
--   deal with errors, with functions such as <a>recover</a>,
--   <a>recoverMany</a>, etc.
runResultT :: Monad m => ResultT msg '[] m a -> m a
type Result e a = ResultT e a Identity
runResult :: Result msg '[] a -> a

-- | Abort the current computation and raise an error to describe the
--   reason
--   
--   Similarly to, e.g. <a>Nothing</a> for <a>Maybe</a>, <a>abort</a> is a
--   computation shortcut. The rest of the monadic computation is not
--   executed, and the error is transmitted to the caller computation.
--   Using the <a>recover</a>, <a>recoverWhile</a> or <a>recoverMany</a>
--   functions to stop the chain.
abort :: ('[e] :| err, Monad m) => e -> ResultT msg err m a

-- | Declaratively describe the purpose of a computation.
--   
--   Using achieve in various places, it becomes possible, once an error is
--   raised, to determine more easily its context. <a>achieve</a> has an
--   operator counterpart: '(<a>?</a>)'. The former should be used to
--   contextualise a do-block, whereas the latter can be prefered for
--   monadic function calls.
--   
--   <pre>
--   achieve "try to get configuration" $ do
--       f &lt;- readParseFile "main" &lt;?&gt; "read main file"
--       f' &lt;- readParseFile "aux" &lt;?&gt; "read aux file"
--       pure $ buildConfiguration f f'
--   </pre>
--   
--   These contextual messages are made available, in addition to the
--   error, when using functions such as <a>recover</a>,
--   <a>recoverMany</a>, <a>repeatUntil</a> etc.
achieve :: (Monad m) => msg -> ResultT msg err m a -> ResultT msg err m a

-- | See <a>achieve</a>.
(<?>) :: (Monad m) => ResultT msg err m a -> msg -> ResultT msg err m a

-- | Always execute a given computation (called finally block thereafter)
--   after a first computation (try block) has been completed.
--   
--   The <a>finally</a> block is executed even if the <tt>try</tt> block is
--   aborted. This allows to deal with clean-up code that has to be
--   executed no matter what happened.
finally :: (Monad m) => ResultT msg err m a -> ResultT msg err m () -> ResultT msg err m a

-- | Temporally allows one given error type by providing an error handler
--   to execute in case of failure.
recover :: forall e m msg err a. (Monad m) => ResultT msg (e : err) m a -> (e -> [msg] -> ResultT msg err m a) -> ResultT msg err m a

-- | Combine <a>recover</a> and <a>achieve</a>.
recoverWhile :: forall e m msg err a. (Monad m) => msg -> ResultT msg (e : err) m a -> (e -> [msg] -> ResultT msg err m a) -> ResultT msg err m a

-- | Similarly to <a>recover</a>, but with more than one error type
--   
--   See <a>+&gt;</a> and <a>eoh</a> to build the <a>Handler</a>.
recoverMany :: forall plus err m msg a. (Split plus err, Monad m) => ResultT msg (Join plus err) m a -> Handler plus ([msg] -> ResultT msg err m a) -> ResultT msg err m a

-- | Similarly to <a>recoverMany</a>, but use the same error handler for
--   every error types.
--   
--   All the error types has to implement a given typeclass.
recoverManyWith :: forall plus c err msg m a. (HaveInstance c plus, Split plus err, Monad m) => ResultT msg (Join plus err) m a -> (forall e. c e => e -> [msg] -> ResultT msg err m a) -> ResultT msg err m a
recoverManyDescriptive :: forall plus err msg m a. (HaveInstance DescriptiveError plus, Split plus err, Monad m) => ResultT msg (Join plus err) m a -> (forall e. DescriptiveError e => e -> [msg] -> ResultT msg err m a) -> ResultT msg err m a

-- | Repeat a computation which may fail until it fails with a given error.
--   
--   Typical use case is reading a file line by line, until reaching its
--   end. If you want to carry some state, you can have a look at
--   <a>foldUntil</a>.
repeatUntil :: forall e err msg m a. (Monad m) => ResultT msg (e : err) m () -> (e -> [msg] -> ResultT msg err m a) -> ResultT msg err m ()

-- | Same as <a>repeatUntil</a>, but without an error handler.
repeatUntil' :: forall e err msg m. (Monad m) => ResultT msg (e : err) m () -> ResultT msg err m ()

-- | Similarly to <a>repeatUntil</a>, repeat a computation until a given
--   error; in addition, carry an accumulator.
foldUntil :: forall e err msg m a. (Monad m) => a -> (a -> ResultT msg (e : err) m a) -> (a -> e -> [msg] -> ResultT msg err m a) -> ResultT msg err m a

-- | Same as <a>foldUntil</a>, but without the error handler part.
foldUntil' :: forall e err msg m a. (Monad m) => a -> (a -> ResultT msg (e : err) m a) -> ResultT msg err m a
eitherOr :: (Monad m) => Either e a -> a -> ResultT msg err m a
exceptOr :: (Monad m, MonadError e m) => m a -> a -> ResultT msg err m a
orAbort :: ('[e] :| err, Monad m) => Maybe a -> e -> ResultT msg err m a
orAbortM :: ('[e] :| err, Monad m) => m (Maybe a) -> e -> ResultT msg err m a
orElse :: (Monad m) => Maybe a -> a -> ResultT msg err m a
orElseM :: (Monad m) => m (Maybe a) -> a -> ResultT msg err m a
eitherAbort :: ('[e] :| err, Monad m) => Either e a -> ResultT msg err m a
exceptAbort :: ('[e] :| err, MonadError e m) => m a -> ResultT msg err m a
data Handler set a
(+>) :: (e -> a) -> Handler set a -> Handler (e : set) a
infixr 9 +>

-- | Stands for “end of handler”.
eoh :: Handler '[] a
class HaveInstance c set
generalize :: HaveInstance c set => (forall e. c e => e -> a) -> Handler set a
class DescriptiveError err
describe :: DescriptiveError err => err -> String
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Chain.ResultT msg err)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Chain.ResultT msg err m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Control.Monad.Chain.ResultT msg err m)
instance Control.Monad.Reader.Class.MonadReader env m => Control.Monad.Reader.Class.MonadReader env (Control.Monad.Chain.ResultT msg err m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Chain.ResultT msg err m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Monad.Chain.ResultT msg err m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Chain.ResultT msg err m)
instance Control.Monad.Chain.HaveInstance c '[]
instance (Control.Monad.Chain.HaveInstance c rst, c e) => Control.Monad.Chain.HaveInstance c (e : rst)
